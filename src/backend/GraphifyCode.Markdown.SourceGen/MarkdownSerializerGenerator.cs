using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable enable

namespace GraphifyCode.Markdown.SourceGen;

[Generator]
public class MarkdownSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typesWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetTypeWithAttribute(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(typesWithAttribute, static (spc, typeSymbol) => Execute(spc, typeSymbol!));
    }

    private static INamedTypeSymbol? GetTypeWithAttribute(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);

        if (symbol is not INamedTypeSymbol typeSymbol)
            return null;

        var hasAttribute = typeSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name is "MarkdownSerializableAttribute" or "MarkdownSerializable");

        return hasAttribute ? typeSymbol : null;
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        var source = GenerateCode(typeSymbol);
        var fileName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace(".", "_");
        context.AddSource($"{fileName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateCode(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.GetMethod is not null)
            .ToList();

        var headerProperty = properties.FirstOrDefault(p => p.GetAttributes()
            .Any(a => a.AttributeClass?.Name is "MarkdownHeaderAttribute" or "MarkdownHeader"));

        // Exclude header property from normal handlers as it's handled separately
        var propertiesToHandle = headerProperty != null
            ? [.. properties.Where(p => !SymbolEqualityComparer.Default.Equals(p, headerProperty))]
            : properties;

        var propertyHandlers = propertiesToHandle.Select(p => PropertyHandlerFactory.Create(p)).ToList();

        var code = new CodeBuilder();
        code
            .Line("// <auto-generated/>")
            .Line("#nullable enable")
            .Line()
            .Nest($"namespace {namespaceName}", ns => ns
                .Nest($"partial class {typeName} : GraphifyCode.Markdown.IMarkdownSerializable<{typeName}>", cls =>
                {
                    GenerateConstructor(cls, typeName);
                    cls.Line();
                    GenerateToMarkdownMethod(cls, typeName, propertyHandlers, headerProperty);
                    cls.Line();
                    GenerateFromMarkdownMethod(cls, typeName, propertyHandlers, headerProperty);
                })
            );

        return code.Code();
    }

    private static void GenerateConstructor(CodeBuilder code, string typeName)
    {
        code
            .Line("[System.Diagnostics.CodeAnalysis.SetsRequiredMembers]")
            .Line($"public {typeName}() {{ }}");
    }

    private static void GenerateToMarkdownMethod(CodeBuilder code, string typeName, List<PropertyHandler> handlers, IPropertySymbol? headerProperty)
    {
        code.Nest("public string ToMarkdown()", method =>
        {
            if (headerProperty != null)
            {
                method.Line($$"""
                    var sb = new System.Text.StringBuilder();
                    sb.AppendLine($"# {{{headerProperty.Name}}}");
                    """);
            }
            else
            {
                method.Line($$"""
                    var sb = new System.Text.StringBuilder();
                    sb.AppendLine("# {{typeName}}");
                    """);
            }

            bool firstProperty = true;
            foreach (var handler in handlers)
            {
                handler.GenerateSerializationCode(method, 1, ref firstProperty);
            }

            method.Line("return sb.ToString().TrimEnd();");
        });
    }

    private static void GenerateFromMarkdownMethod(CodeBuilder code, string typeName, List<PropertyHandler> handlers, IPropertySymbol? headerProperty)
    {
        code.Nest($"public static {typeName} FromMarkdown(string markdown)", method =>
        {
            method.Line($$"""
                var lines = markdown.Split(new[] { '\r', '\n' }, System.StringSplitOptions.RemoveEmptyEntries);
                var index = 0;
                var obj = new {{typeName}}();

                """);

            if (headerProperty != null)
            {
                method.Line($$"""
                    // Parse header and extract {{headerProperty.Name}}
                    if (index < lines.Length && lines[index].StartsWith("# "))
                    {
                        obj.{{headerProperty.Name}} = lines[index].Substring(2);
                        index++;
                    }
                    """);
            }
            else
            {
                method.Line($$"""
                    // Skip header
                    if (index < lines.Length && lines[index].StartsWith("# "))
                        index++;
                    """);
            }

            // Group handlers by type
            var primitiveHandlers = handlers.Where(h => h is PrimitivePropertyHandler).ToList();
            var nestedHandlers = handlers.Where(h => h is NestedObjectPropertyHandler).ToList();
            var arrayHandlers = handlers.Where(h => h is ArrayPropertyHandler || h is ArrayOfObjectsPropertyHandler).ToList();

            // Parse primitive properties
            if (primitiveHandlers.Any())
            {
                method.Line();
                method.Nest("// Parse primitive properties\nwhile (index < lines.Length && lines[index].StartsWith(\"- \"))", loop =>
                {
                    loop.Line("var line = lines[index];");
                    foreach (var handler in primitiveHandlers)
                    {
                        handler.GenerateDeserializationCode(loop, 1);
                    }
                    loop.Line("index++;");
                });
            }

            // Parse nested objects and arrays
            method.Line();
            foreach (var handler in nestedHandlers.Concat(arrayHandlers))
            {
                handler.GenerateDeserializationCode(method, 1);
            }

            method.Line();
            method.Line("return obj;");
        });
    }

    // Abstract base class for property handlers
    private abstract class PropertyHandler(IPropertySymbol property)
    {
        protected IPropertySymbol Property { get; } = property;

        public abstract void GenerateSerializationCode(CodeBuilder code, int currentLevel, ref bool firstProperty);
        public abstract void GenerateDeserializationCode(CodeBuilder code, int currentLevel);

        protected static string GetHeaderPrefix(int level) => new('#', level + 1);
    }

    // Factory to create appropriate handler for each property type
    private static class PropertyHandlerFactory
    {
        public static PropertyHandler Create(IPropertySymbol property)
        {
            var propertyType = property.Type;

            if (propertyType is IArrayTypeSymbol arrayType)
            {
                var elementType = arrayType.ElementType;
                return IsPrimitiveOrString(elementType)
                    ? new ArrayPropertyHandler(property, elementType)
                    : new ArrayOfObjectsPropertyHandler(property, elementType);
            }

            return IsPrimitiveOrString(propertyType)
                ? new PrimitivePropertyHandler(property)
                : new NestedObjectPropertyHandler(property);
        }
    }

    // Handler for primitive properties
    private class PrimitivePropertyHandler(IPropertySymbol property) : PropertyHandler(property)
    {
        public override void GenerateSerializationCode(CodeBuilder code, int currentLevel, ref bool firstProperty)
        {
            firstProperty = false;
            var formatExpr = GetFormatExpression(Property.Type, Property.Name);

            // Check if property is nullable
            if (IsNullableType(Property.Type))
            {
                code.Nest($"if ({Property.Name} != null)", ifBlock =>
                {
                    ifBlock.Line($"sb.AppendLine($\"- {Property.Name}: {{{formatExpr}}}\");");
                });
            }
            else
            {
                code.Line($"sb.AppendLine($\"- {Property.Name}: {{{formatExpr}}}\");");
            }
        }

        public override void GenerateDeserializationCode(CodeBuilder code, int currentLevel)
        {
            var parseExpr = GetParseExpression(Property.Type, "value");
            code.Nest($"if (line.StartsWith(\"- {Property.Name}: \"))", ifBlock =>
            {
                ifBlock.Line($$"""
                    var value = line.Substring({{2 + Property.Name.Length + 2}});
                    obj.{{Property.Name}} = {{parseExpr}};
                    """);
            });
        }
    }

    // Handler for array of primitives
    private class ArrayPropertyHandler(IPropertySymbol property, ITypeSymbol elementType) : PropertyHandler(property)
    {
        public override void GenerateSerializationCode(CodeBuilder code, int currentLevel, ref bool firstProperty)
        {
            firstProperty = false;
            var header = GetHeaderPrefix(currentLevel);
            var formatExpr = GetFormatExpression(elementType, "item");
            code.Line($$"""
                sb.AppendLine();
                sb.AppendLine("{{header}} {{Property.Name}}");
                foreach (var item in {{Property.Name}})
                    sb.AppendLine($"- {{{formatExpr}}}");
                """);
        }

        public override void GenerateDeserializationCode(CodeBuilder code, int currentLevel)
        {
            var header = GetHeaderPrefix(currentLevel);
            var listName = $"{Property.Name.ToLowerInvariant()}List";
            var parseExpr = GetParseExpression(elementType, "value");

            code.Line($$"""
                // Parse {{Property.Name}}
                if (index < lines.Length && lines[index] == "{{header}} {{Property.Name}}")
                {
                    index++;
                    var {{listName}} = new System.Collections.Generic.List<{{elementType.ToDisplayString()}}>();
                    while (index < lines.Length && lines[index].StartsWith("- "))
                    {
                        var value = lines[index].Substring(2);
                        {{listName}}.Add({{parseExpr}});
                        index++;
                    }
                    obj.{{Property.Name}} = {{listName}}.ToArray();
                }
                """);
        }
    }

    // Handler for nested objects
    private class NestedObjectPropertyHandler(IPropertySymbol property) : PropertyHandler(property)
    {
        public override void GenerateSerializationCode(CodeBuilder code, int currentLevel, ref bool firstProperty)
        {
            firstProperty = false;
            var header = GetHeaderPrefix(currentLevel);
            code.Line($$"""
                sb.AppendLine();
                sb.AppendLine("{{header}} {{Property.Name}}");
                var nested{{Property.Name}}Lines = {{Property.Name}}.ToMarkdown().Split(new[] { '\r', '\n' }, System.StringSplitOptions.RemoveEmptyEntries);
                for (int i = 1; i < nested{{Property.Name}}Lines.Length; i++)
                    sb.AppendLine(nested{{Property.Name}}Lines[i]);
                """);
        }

        public override void GenerateDeserializationCode(CodeBuilder code, int currentLevel)
        {
            var header = GetHeaderPrefix(currentLevel);
            code.Line($$"""
                // Parse {{Property.Name}}
                if (index < lines.Length && lines[index] == "{{header}} {{Property.Name}}")
                {
                    index++;
                    var nestedLines = new System.Text.StringBuilder();
                    nestedLines.AppendLine("# {{Property.Type.Name}}");
                    while (index < lines.Length && lines[index].StartsWith("- "))
                    {
                        nestedLines.AppendLine(lines[index]);
                        index++;
                    }
                    obj.{{Property.Name}} = {{Property.Type.ToDisplayString()}}.FromMarkdown(nestedLines.ToString());
                }
                """);
        }
    }

    // Handler for array of complex objects
    private class ArrayOfObjectsPropertyHandler(IPropertySymbol property, ITypeSymbol elementType) : PropertyHandler(property)
    {
        public override void GenerateSerializationCode(CodeBuilder code, int currentLevel, ref bool firstProperty)
        {
            firstProperty = false;
            var currentHeader = new string('#', currentLevel);
            var nextHeader = GetHeaderPrefix(currentLevel);

            // Check if element type has a property marked with MarkdownHeader
            var headerProperty = GetMarkdownHeaderProperty(elementType);

            if (headerProperty != null)
            {
                code.Line($$"""
                    sb.AppendLine();
                    foreach (var item in {{Property.Name}})
                    {
                        var itemMarkdown = item.ToMarkdown();
                        var itemLines = itemMarkdown.Split(new[] { "\r\n", "\r", "\n" }, System.StringSplitOptions.None);
                        sb.AppendLine($"{{nextHeader}} {item.{{headerProperty.Name}}}");
                        for (int i = 1; i < itemLines.Length; i++)
                        {
                            var line = itemLines[i];
                            if (string.IsNullOrEmpty(line))
                            {
                                sb.AppendLine();
                                continue;
                            }
                            if (line.StartsWith("- {{headerProperty.Name}}: "))
                                continue;
                            if (line.StartsWith("{{currentHeader}}"))
                                sb.AppendLine(line.Substring({{currentLevel - 1}}).Insert(0, "{{nextHeader.Substring(0, currentLevel)}}"));
                            else
                                sb.AppendLine(line);
                        }
                        sb.AppendLine();
                    }
                    """);
            }
            else
            {
                code.Line($$"""
                    sb.AppendLine();
                    foreach (var item in {{Property.Name}})
                    {
                        sb.AppendLine(item.ToMarkdown().Replace("{{currentHeader}} ", "{{nextHeader}} "));
                        sb.AppendLine();
                    }
                    """);
            }
        }

        public override void GenerateDeserializationCode(CodeBuilder code, int currentLevel)
        {
            var header = GetHeaderPrefix(currentLevel);
            var listName = $"{Property.Name.ToLowerInvariant()}List";
            var headerProperty = GetMarkdownHeaderProperty(elementType);

            code.Line($$"""
                // Parse {{Property.Name}}
                var {{listName}} = new System.Collections.Generic.List<{{elementType.ToDisplayString()}}>();
                while (index < lines.Length && lines[index].StartsWith("{{header}} "))
                {
                    var itemStart = index;
                    index++;
                    while (index < lines.Length && !lines[index].StartsWith("{{header}} "))
                    {
                        // Check if we hit a header of same or higher level
                        if (lines[index].StartsWith("#"))
                        {
                            bool isSameOrHigherLevel = true;
                            for (int h = 0; h < {{currentLevel + 1}}; h++)
                            {
                                if (h >= lines[index].Length || lines[index][h] != '#')
                                {
                                    isSameOrHigherLevel = false;
                                    break;
                                }
                            }
                            if (isSameOrHigherLevel && ({{currentLevel + 1}} >= lines[index].Length || lines[index][{{currentLevel + 1}}] != '#'))
                                break;
                        }
                        index++;
                    }

                    var itemLines = new System.Collections.Generic.List<string>();
                """);

            if (headerProperty != null)
            {
                code.Line($$"""
                        var headerValue = lines[itemStart].Substring({{currentLevel + 2}});
                        itemLines.Add($"# {headerValue}");
                    """);
            }
            else
            {
                code.Line($$"""
                        itemLines.Add("# {{elementType.Name}}");
                    """);
            }

            code.Line($$"""
                    for (int i = itemStart + 1; i < index; i++)
                    {
                        var line = lines[i];
                        if (line.StartsWith("{{header}}"))
                            line = line.Substring({{currentLevel}});
                        itemLines.Add(line);
                    }

                    var itemMarkdown = string.Join("\n", itemLines);
                    {{listName}}.Add({{elementType.ToDisplayString()}}.FromMarkdown(itemMarkdown));
                }
                obj.{{Property.Name}} = {{listName}}.ToArray();
                """);
        }

        private static IPropertySymbol? GetMarkdownHeaderProperty(ITypeSymbol type)
        {
            if (type is not INamedTypeSymbol namedType)
                return null;

            return namedType.GetMembers()
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.GetAttributes()
                    .Any(a => a.AttributeClass?.Name is "MarkdownHeaderAttribute" or "MarkdownHeader"));
        }
    }

    // Helper methods
    private static string GetFormatExpression(ITypeSymbol type, string propertyName)
    {
        // Handle nullable types
        if (type is INamedTypeSymbol { NullableAnnotation: NullableAnnotation.Annotated, OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            var underlyingType = namedType.TypeArguments[0];
            if (underlyingType.SpecialType == SpecialType.System_DateTime ||
                (underlyingType.Name == "DateTime" && underlyingType.ContainingNamespace?.ToDisplayString() == "System"))
            {
                return $"{propertyName}.Value.ToString(\"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)";
            }
            return $"{propertyName}.Value";
        }

        if (type.SpecialType == SpecialType.System_DateTime ||
            (type.Name == "DateTime" && type.ContainingNamespace?.ToDisplayString() == "System"))
        {
            return $"{propertyName}.ToString(\"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)";
        }
        return propertyName;
    }

    private static bool IsNullableType(ITypeSymbol type)
    {
        // Check for Nullable<T>
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T })
            return true;

        // Check for reference types with nullable annotation
        if (type.IsReferenceType && type.NullableAnnotation == NullableAnnotation.Annotated)
            return true;

        return false;
    }

    private static string GetParseExpression(ITypeSymbol type, string variableName)
    {
        // Handle nullable types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            var underlyingType = namedType.TypeArguments[0];
            var underlyingParseExpr = underlyingType.SpecialType switch
            {
                SpecialType.System_Boolean => $"bool.Parse({variableName})",
                SpecialType.System_Byte => $"byte.Parse({variableName})",
                SpecialType.System_SByte => $"sbyte.Parse({variableName})",
                SpecialType.System_Int16 => $"short.Parse({variableName})",
                SpecialType.System_UInt16 => $"ushort.Parse({variableName})",
                SpecialType.System_Int32 => $"int.Parse({variableName})",
                SpecialType.System_UInt32 => $"uint.Parse({variableName})",
                SpecialType.System_Int64 => $"long.Parse({variableName})",
                SpecialType.System_UInt64 => $"ulong.Parse({variableName})",
                SpecialType.System_Single => $"float.Parse({variableName})",
                SpecialType.System_Double => $"double.Parse({variableName})",
                SpecialType.System_Decimal => $"decimal.Parse({variableName})",
                SpecialType.System_Char => $"char.Parse({variableName})",
                SpecialType.System_DateTime => $"System.DateTime.ParseExact({variableName}, \"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)",
                _ => underlyingType.Name switch
                {
                    "Guid" => $"System.Guid.Parse({variableName})",
                    "DateTime" => $"System.DateTime.ParseExact({variableName}, \"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)",
                    _ => variableName
                }
            };
            return underlyingParseExpr;
        }

        // Handle nullable reference types
        if (type.IsReferenceType && type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            return variableName;
        }

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => $"bool.Parse({variableName})",
            SpecialType.System_Byte => $"byte.Parse({variableName})",
            SpecialType.System_SByte => $"sbyte.Parse({variableName})",
            SpecialType.System_Int16 => $"short.Parse({variableName})",
            SpecialType.System_UInt16 => $"ushort.Parse({variableName})",
            SpecialType.System_Int32 => $"int.Parse({variableName})",
            SpecialType.System_UInt32 => $"uint.Parse({variableName})",
            SpecialType.System_Int64 => $"long.Parse({variableName})",
            SpecialType.System_UInt64 => $"ulong.Parse({variableName})",
            SpecialType.System_Single => $"float.Parse({variableName})",
            SpecialType.System_Double => $"double.Parse({variableName})",
            SpecialType.System_Decimal => $"decimal.Parse({variableName})",
            SpecialType.System_Char => $"char.Parse({variableName})",
            SpecialType.System_String => variableName,
            SpecialType.System_DateTime => $"System.DateTime.ParseExact({variableName}, \"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)",
            _ => type.Name switch
            {
                "Guid" => $"System.Guid.Parse({variableName})",
                "DateTime" => $"System.DateTime.ParseExact({variableName}, \"dd.MM.yyyy HH:mm:ss\", System.Globalization.CultureInfo.InvariantCulture)",
                _ => variableName
            }
        };
    }

    private static bool IsPrimitiveOrString(ITypeSymbol type)
    {
        // Handle nullable types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            return IsPrimitiveOrString(namedType.TypeArguments[0]);
        }

        // Handle nullable reference types
        if (type.IsReferenceType && type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            var nonNullableType = type.WithNullableAnnotation(NullableAnnotation.NotAnnotated);
            return IsPrimitiveOrString(nonNullableType);
        }

        return type.SpecialType switch
        {
            SpecialType.System_Boolean or
            SpecialType.System_Byte or
            SpecialType.System_SByte or
            SpecialType.System_Int16 or
            SpecialType.System_UInt16 or
            SpecialType.System_Int32 or
            SpecialType.System_UInt32 or
            SpecialType.System_Int64 or
            SpecialType.System_UInt64 or
            SpecialType.System_Single or
            SpecialType.System_Double or
            SpecialType.System_Decimal or
            SpecialType.System_Char or
            SpecialType.System_String or
            SpecialType.System_DateTime => true,
            _ => (type.Name == "Guid" || type.Name == "DateTime") && type.ContainingNamespace?.ToDisplayString() == "System"
        };
    }
}
