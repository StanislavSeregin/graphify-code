using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

#nullable enable

namespace GraphifyCode.Markdown.SourceGen;

[Generator]
public class MarkdownSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all types with MarkdownSerializable attribute
        var typesWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetTypeWithAttribute(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(typesWithAttribute, static (spc, typeSymbol) => Execute(spc, typeSymbol!));
    }

    private static INamedTypeSymbol? GetTypeWithAttribute(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);

        if (symbol is not INamedTypeSymbol typeSymbol)
            return null;

        // Check if type has MarkdownSerializable attribute
        var hasAttribute = typeSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name is "MarkdownSerializableAttribute" or "MarkdownSerializable");

        return hasAttribute ? typeSymbol : null;
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        var source = GenerateSerializationCode(typeSymbol);
        context.AddSource($"{typeSymbol.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateSerializationCode(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.GetMethod is not null)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    partial class {typeName} : GraphifyCode.Markdown.IMarkdownSerializable");
        sb.AppendLine("    {");
        sb.AppendLine($"        public string ToMarkdown()");
        sb.AppendLine("        {");
        sb.AppendLine("            var sb = new System.Text.StringBuilder();");
        sb.AppendLine($"            sb.AppendLine(\"# {typeName}\");");

        bool firstProperty = true;
        foreach (var property in properties)
        {
            var propertyType = property.Type;
            var isArray = propertyType is IArrayTypeSymbol;
            var elementType = isArray ? ((IArrayTypeSymbol)propertyType).ElementType : propertyType;
            var isPrimitive = IsPrimitiveOrString(elementType);

            if (isArray)
            {
                // Always add blank line before arrays
                sb.AppendLine("            sb.AppendLine();");

                if (isPrimitive)
                {
                    // Array of primitives
                    sb.AppendLine($"            sb.AppendLine(\"## {property.Name}\");");
                    sb.AppendLine($"            foreach (var item in {property.Name})");
                    sb.AppendLine("            {");
                    sb.AppendLine("                sb.AppendLine($\"- {item}\");");
                    sb.AppendLine("            }");
                }
                else
                {
                    // Array of complex objects
                    sb.AppendLine($"            foreach (var item in {property.Name})");
                    sb.AppendLine("            {");
                    sb.AppendLine("                sb.AppendLine(item.ToMarkdown().Replace(\"# \", \"## \"));");
                    sb.AppendLine("                sb.AppendLine();"); // Blank line between elements
                    sb.AppendLine("            }");
                }
                firstProperty = false;
            }
            else
            {
                // Simple property
                if (firstProperty)
                {
                    firstProperty = false;
                }
                sb.AppendLine($"            sb.AppendLine($\"- {property.Name}: {{{property.Name}}}\");");
            }
        }

        sb.AppendLine("            return sb.ToString().TrimEnd();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static bool IsPrimitiveOrString(ITypeSymbol type) => type.SpecialType switch
    {
        SpecialType.System_Boolean or
        SpecialType.System_Byte or
        SpecialType.System_SByte or
        SpecialType.System_Int16 or
        SpecialType.System_UInt16 or
        SpecialType.System_Int32 or
        SpecialType.System_UInt32 or
        SpecialType.System_Int64 or
        SpecialType.System_UInt64 or
        SpecialType.System_Single or
        SpecialType.System_Double or
        SpecialType.System_Decimal or
        SpecialType.System_Char or
        SpecialType.System_String => true,
        _ => type.Name == "Guid" && type.ContainingNamespace?.ToDisplayString() == "System"
    };
}
