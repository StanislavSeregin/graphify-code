using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable enable

namespace GraphifyCode.Markdown.SourceGen;

[Generator]
public class MarkdownSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all types with MarkdownSerializable attribute
        var typesWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetTypeWithAttribute(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(typesWithAttribute, static (spc, typeSymbol) => Execute(spc, typeSymbol!));
    }

    private static INamedTypeSymbol? GetTypeWithAttribute(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);

        if (symbol is not INamedTypeSymbol typeSymbol)
            return null;

        // Check if type has MarkdownSerializable attribute
        var hasAttribute = typeSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name is "MarkdownSerializableAttribute" or "MarkdownSerializable");

        return hasAttribute ? typeSymbol : null;
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        var source = GenerateCode(typeSymbol);
        context.AddSource($"{typeSymbol.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateCode(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.GetMethod is not null)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    partial class {typeName} : GraphifyCode.Markdown.IMarkdownSerializable<{typeName}>");
        sb.AppendLine("    {");

        // Generate private constructor for deserialization
        GenerateDeserializationConstructor(sb, typeName);

        sb.AppendLine();

        // Generate ToMarkdown method
        GenerateToMarkdownMethod(sb, typeName, properties);

        sb.AppendLine();

        // Generate FromMarkdown method
        GenerateFromMarkdownMethod(sb, typeName, properties);

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateDeserializationConstructor(StringBuilder sb, string typeName)
    {
        sb.AppendLine($"        [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]");
        sb.AppendLine($"        public {typeName}() {{ }}");
    }

    private static void GenerateToMarkdownMethod(StringBuilder sb, string typeName, List<IPropertySymbol> properties)
    {
        sb.AppendLine($"        public string ToMarkdown()");
        sb.AppendLine("        {");
        sb.AppendLine("            var sb = new System.Text.StringBuilder();");
        sb.AppendLine($"            sb.AppendLine(\"# {typeName}\");");

        bool firstProperty = true;
        foreach (var property in properties)
        {
            var propertyType = property.Type;
            var isArray = propertyType is IArrayTypeSymbol;
            var elementType = isArray ? ((IArrayTypeSymbol)propertyType).ElementType : propertyType;
            var isPrimitive = IsPrimitiveOrString(elementType);

            if (isArray)
            {
                // Always add blank line before arrays
                sb.AppendLine("            sb.AppendLine();");

                if (isPrimitive)
                {
                    // Array of primitives
                    sb.AppendLine($"            sb.AppendLine(\"## {property.Name}\");");
                    sb.AppendLine($"            foreach (var item in {property.Name})");
                    sb.AppendLine("            {");
                    sb.AppendLine("                sb.AppendLine($\"- {item}\");");
                    sb.AppendLine("            }");
                }
                else
                {
                    // Array of complex objects
                    sb.AppendLine($"            foreach (var item in {property.Name})");
                    sb.AppendLine("            {");
                    sb.AppendLine("                sb.AppendLine(item.ToMarkdown().Replace(\"# \", \"## \"));");
                    sb.AppendLine("                sb.AppendLine();"); // Blank line between elements
                    sb.AppendLine("            }");
                }
                firstProperty = false;
            }
            else
            {
                if (isPrimitive)
                {
                    // Primitive property
                    if (firstProperty)
                    {
                        firstProperty = false;
                    }
                    sb.AppendLine($"            sb.AppendLine($\"- {property.Name}: {{{property.Name}}}\");");
                }
                else
                {
                    // Nested object
                    sb.AppendLine("            sb.AppendLine();");
                    sb.AppendLine($"            sb.AppendLine(\"## {property.Name}\");");
                    sb.AppendLine($"            var nested{property.Name}Lines = {property.Name}.ToMarkdown().Split(new[] {{ '\\r', '\\n' }}, System.StringSplitOptions.RemoveEmptyEntries);");
                    sb.AppendLine($"            for (int i = 1; i < nested{property.Name}Lines.Length; i++)"); // Skip header
                    sb.AppendLine($"                sb.AppendLine(nested{property.Name}Lines[i]);");
                    firstProperty = false;
                }
            }
        }

        sb.AppendLine("            return sb.ToString().TrimEnd();");
        sb.AppendLine("        }");
    }

    private static void GenerateFromMarkdownMethod(StringBuilder sb, string typeName, List<IPropertySymbol> properties)
    {
        sb.AppendLine($"        public static {typeName} FromMarkdown(string markdown)");
        sb.AppendLine("        {");
        sb.AppendLine("            var lines = markdown.Split(new[] { '\\r', '\\n' }, System.StringSplitOptions.RemoveEmptyEntries);");
        sb.AppendLine("            var index = 0;");
        sb.AppendLine($"            var obj = new {typeName}();");
        sb.AppendLine();
        sb.AppendLine("            // Skip header");
        sb.AppendLine($"            if (index < lines.Length && lines[index].StartsWith(\"# {typeName}\"))");
        sb.AppendLine("                index++;");
        sb.AppendLine();

        // Parse primitive properties first
        var primitiveProperties = properties.Where(p => p.Type is not IArrayTypeSymbol && IsPrimitiveOrString(p.Type)).ToList();
        if (primitiveProperties.Any())
        {
            sb.AppendLine("            // Parse primitive properties");
            sb.AppendLine("            while (index < lines.Length && lines[index].StartsWith(\"- \"))");
            sb.AppendLine("            {");
            sb.AppendLine("                var line = lines[index];");

            foreach (var property in primitiveProperties)
            {
                sb.AppendLine($"                if (line.StartsWith(\"- {property.Name}: \"))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    var value = line.Substring({2 + property.Name.Length + 2});");
                sb.AppendLine($"                    obj.{property.Name} = {GetParseExpression(property.Type, "value")};");
                sb.AppendLine("                }");
            }

            sb.AppendLine("                index++;");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // Parse nested objects
        var nestedObjectProperties = properties.Where(p => p.Type is not IArrayTypeSymbol && !IsPrimitiveOrString(p.Type)).ToList();
        foreach (var property in nestedObjectProperties)
        {
            sb.AppendLine($"            // Parse {property.Name}");
            sb.AppendLine($"            if (index < lines.Length && lines[index] == \"## {property.Name}\")");
            sb.AppendLine("            {");
            sb.AppendLine("                index++;");
            sb.AppendLine($"                var nestedLines = new System.Text.StringBuilder();");
            sb.AppendLine($"                nestedLines.AppendLine(\"# {property.Type.Name}\");");
            sb.AppendLine("                while (index < lines.Length && lines[index].StartsWith(\"- \"))");
            sb.AppendLine("                {");
            sb.AppendLine("                    nestedLines.AppendLine(lines[index]);");
            sb.AppendLine("                    index++;");
            sb.AppendLine("                }");
            sb.AppendLine($"                obj.{property.Name} = {property.Type.ToDisplayString()}.FromMarkdown(nestedLines.ToString());");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // Parse arrays
        foreach (var property in properties)
        {
            var propertyType = property.Type;
            var isArray = propertyType is IArrayTypeSymbol;

            if (!isArray)
                continue;

            var elementType = ((IArrayTypeSymbol)propertyType).ElementType;
            var isPrimitive = IsPrimitiveOrString(elementType);

            if (isArray)
            {
                if (isPrimitive)
                {
                    // Array of primitives
                    sb.AppendLine($"            // Parse {property.Name}");
                    sb.AppendLine($"            if (index < lines.Length && lines[index] == \"## {property.Name}\")");
                    sb.AppendLine("            {");
                    sb.AppendLine("                index++;");
                    sb.AppendLine($"                var {property.Name.ToLowerInvariant()}List = new System.Collections.Generic.List<{elementType.ToDisplayString()}>();");
                    sb.AppendLine($"                while (index < lines.Length && lines[index].StartsWith(\"- \"))");
                    sb.AppendLine("                {");
                    sb.AppendLine($"                    var value = lines[index].Substring(2);");
                    sb.AppendLine($"                    {property.Name.ToLowerInvariant()}List.Add({GetParseExpression(elementType, "value")});");
                    sb.AppendLine("                    index++;");
                    sb.AppendLine("                }");
                    sb.AppendLine($"                obj.{property.Name} = {property.Name.ToLowerInvariant()}List.ToArray();");
                    sb.AppendLine("            }");
                    sb.AppendLine();
                }
                else
                {
                    // Array of complex objects
                    sb.AppendLine($"            // Parse {property.Name}");
                    sb.AppendLine($"            var {property.Name.ToLowerInvariant()}List = new System.Collections.Generic.List<{elementType.ToDisplayString()}>();");
                    sb.AppendLine($"            while (index < lines.Length && lines[index].StartsWith(\"## {elementType.Name}\"))");
                    sb.AppendLine("            {");
                    sb.AppendLine("                var itemStart = index;");
                    sb.AppendLine("                index++;");
                    sb.AppendLine("                while (index < lines.Length && lines[index].StartsWith(\"- \"))");
                    sb.AppendLine("                    index++;");
                    sb.AppendLine();
                    sb.AppendLine("                var itemLines = new System.Collections.Generic.List<string> { lines[itemStart] };");
                    sb.AppendLine("                for (int i = itemStart + 1; i < index; i++)");
                    sb.AppendLine("                    itemLines.Add(lines[i]);");
                    sb.AppendLine();
                    sb.AppendLine($"                var itemMarkdown = string.Join(\"\\n\", itemLines).Replace(\"## {elementType.Name}\", \"# {elementType.Name}\");");
                    sb.AppendLine($"                {property.Name.ToLowerInvariant()}List.Add({elementType.ToDisplayString()}.FromMarkdown(itemMarkdown));");
                    sb.AppendLine("            }");
                    sb.AppendLine($"            obj.{property.Name} = {property.Name.ToLowerInvariant()}List.ToArray();");
                    sb.AppendLine();
                }
            }
        }

        sb.AppendLine("            return obj;");
        sb.AppendLine("        }");
    }

    private static string GetParseExpression(ITypeSymbol type, string variableName)
    {
        return type.SpecialType switch
        {
            SpecialType.System_Boolean => $"bool.Parse({variableName})",
            SpecialType.System_Byte => $"byte.Parse({variableName})",
            SpecialType.System_SByte => $"sbyte.Parse({variableName})",
            SpecialType.System_Int16 => $"short.Parse({variableName})",
            SpecialType.System_UInt16 => $"ushort.Parse({variableName})",
            SpecialType.System_Int32 => $"int.Parse({variableName})",
            SpecialType.System_UInt32 => $"uint.Parse({variableName})",
            SpecialType.System_Int64 => $"long.Parse({variableName})",
            SpecialType.System_UInt64 => $"ulong.Parse({variableName})",
            SpecialType.System_Single => $"float.Parse({variableName})",
            SpecialType.System_Double => $"double.Parse({variableName})",
            SpecialType.System_Decimal => $"decimal.Parse({variableName})",
            SpecialType.System_Char => $"char.Parse({variableName})",
            SpecialType.System_String => variableName,
            _ => type.Name == "Guid" ? $"System.Guid.Parse({variableName})" : variableName
        };
    }

    private static bool IsPrimitiveOrString(ITypeSymbol type) => type.SpecialType switch
    {
        SpecialType.System_Boolean or
        SpecialType.System_Byte or
        SpecialType.System_SByte or
        SpecialType.System_Int16 or
        SpecialType.System_UInt16 or
        SpecialType.System_Int32 or
        SpecialType.System_UInt32 or
        SpecialType.System_Int64 or
        SpecialType.System_UInt64 or
        SpecialType.System_Single or
        SpecialType.System_Double or
        SpecialType.System_Decimal or
        SpecialType.System_Char or
        SpecialType.System_String => true,
        _ => type.Name == "Guid" && type.ContainingNamespace?.ToDisplayString() == "System"
    };
}
